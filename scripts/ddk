#!/usr/bin/env bash
set -euo pipefail

prog=$(basename "$0")

# Check and configure image source
DDK_CONFIG="$HOME/.ddk"
if [[ ! -f "$DDK_CONFIG" ]]; then
  echo "First run detected. Please select an image source:"
  echo "1. cnb (docker.cnb.cool/ylarod/ddk)"
  echo "2. github (ghcr.io/ylarod/ddk)"
  echo "3. docker (docker.io/ylarod/ddk)"
  echo ""
  echo "Waiting 30 seconds (default: github)..."

  choice=""
  if read -t 30 -p "Enter your choice (1/2/3): " choice; then
    echo ""
  else
    echo ""
    echo "Timeout: defaulting to github source"
    choice="2"
  fi

  case "$choice" in
    1)
      echo "cnb" > "$DDK_CONFIG"
      echo "Selected: cnb source"
      ;;
    2)
      echo "github" > "$DDK_CONFIG"
      echo "Selected: github source"
      ;;
    3)
      echo "docker" > "$DDK_CONFIG"
      echo "Selected: docker source"
      ;;
    *)
      echo "Invalid option, defaulting to github source" >&2
      echo "github" > "$DDK_CONFIG"
      ;;
  esac
fi

# Read configured source
SOURCE=$(cat "$DDK_CONFIG")
case "$SOURCE" in
  cnb)
    IMAGE_BASE="docker.cnb.cool/ylarod/ddk"
    ;;
  github)
    IMAGE_BASE="ghcr.io/ylarod/ddk"
    ;;
  docker)
    IMAGE_BASE="docker.io/ylarod/ddk"
    ;;
  *)
    echo "Warning: unknown source configuration '$SOURCE', using default github source" >&2
    IMAGE_BASE="ghcr.io/ylarod/ddk"
    ;;
esac

usage() {
  cat <<EOF
Usage: $prog <command> [options] [-- <make-args>]

Commands:
  list                                        List all pulled DDK images
  list-all                                    List all available DDK targets from repository
  pull <target>|--target <target>             Pull image $IMAGE_BASE:<target>
  build [<target>] [--target <target>] [-- <make-args>]
                                              Run 'make' inside container (for building)
  clean [<target>] [--target <target>]
                                              Run 'make clean' inside container
  shell [<target>] [--target <target>]
                                              Start an interactive shell in the container
  update                                      Update ddk script to the latest version

Options:
  --target, -t   image tag like 'android12-5.10' (defaults to DDK_TARGET env if unset)
  (docker platform is forced to linux/amd64)
  -h, --help     show this help

Examples:
  $prog list
  $prog list-all
  $prog pull android12-5.10
  $prog pull --target android12-5.10
  $prog build android12-5.10 -- CFLAGS=-O2
  $prog build --target android12-5.10 -- CFLAGS=-O2
  $prog clean -t android12-5.10
  $prog shell android12-5.10
  $prog update
EOF
}

if [ $# -lt 1 ]; then
  usage
  exit 1
fi

if [[ "$1" == "--help" || "$1" == "-h" ]]; then
  usage
  exit 1
fi

cmd=$1; shift

TARGET=""
MAKE_ARGS=()

# Simple flag/positional parser
while [[ $# -gt 0 ]]; do
  case "$1" in
    --target|-t)
      TARGET="$2"; shift 2;;
    --help|-h)
      usage
      exit 0
      ;;
    --)
      shift
      MAKE_ARGS=("$@")
      break
      ;;
    -*)
      # unknown flag for wrapper - treat as error
      echo "Unknown option: $1" >&2; exit 2;
      ;;
    *)
      # positional: if no target yet, take this as target; otherwise treat as a make arg
      if [[ -z "$TARGET" ]]; then
        TARGET="$1"
      else
        MAKE_ARGS+=("$1")
      fi
      shift
      ;;
  esac
done

# Handle 'list', 'list-all', and 'update' commands early since they don't need TARGET
if [[ "$cmd" == "list" ]]; then
  echo "Pulled DDK images:"
  docker images --filter "reference=$IMAGE_BASE" --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
  exit 0
fi

if [[ "$cmd" == "list-all" ]]; then
  # Determine mapping.json URL based on source
  case "$SOURCE" in
    cnb)
      MAPPING_URL="https://cnb.cool/Ylarod/ddk/-/git/raw/main/mapping.json?download=true"
      ;;
    github|docker|*)
      MAPPING_URL="https://raw.githubusercontent.com/Ylarod/ddk/main/mapping.json"
      ;;
  esac

  echo "Fetching available targets from: $MAPPING_URL"
  echo ""

  TEMP_JSON=$(mktemp)
  if ! curl -fsSL "$MAPPING_URL" -o "$TEMP_JSON"; then
    rm -f "$TEMP_JSON"
    echo "Error: failed to download mapping.json" >&2
    exit 1
  fi

  echo "Available Targets:"
  echo "------------------"

  # Check if jq is available
  if command -v jq &> /dev/null; then
    jq -r '.android[] | .name' "$TEMP_JSON" | sed 's/^/  /'
  else
    # Fallback: simple grep-based parsing if jq is not available
    grep -o '"name": "[^"]*"' "$TEMP_JSON" | cut -d'"' -f4 | sed 's/^/  /'
  fi

  rm -f "$TEMP_JSON"
  exit 0
fi

if [[ "$cmd" == "update" ]]; then
  SCRIPT_PATH=$(command -v ddk 2>/dev/null || echo "")
  if [[ -z "$SCRIPT_PATH" ]]; then
    echo "Error: cannot find ddk script location" >&2
    exit 1
  fi

  SCRIPT_PATH=$(readlink -f "$SCRIPT_PATH" 2>/dev/null || realpath "$SCRIPT_PATH" 2>/dev/null || echo "$SCRIPT_PATH")

  # Determine download URL based on source
  case "$SOURCE" in
    cnb)
      DOWNLOAD_URL="https://cnb.cool/Ylarod/ddk/-/git/raw/main/scripts/ddk?download=true"
      ;;
    github|docker|*)
      DOWNLOAD_URL="https://raw.githubusercontent.com/Ylarod/ddk/main/scripts/ddk"
      ;;
  esac

  echo "Updating ddk script at: $SCRIPT_PATH"
  echo "Downloading from: $DOWNLOAD_URL"

  TEMP_FILE=$(mktemp)
  if curl -fsSL "$DOWNLOAD_URL" -o "$TEMP_FILE"; then
    if [[ -w "$SCRIPT_PATH" ]]; then
      mv "$TEMP_FILE" "$SCRIPT_PATH"
      chmod +x "$SCRIPT_PATH"
      echo "Successfully updated ddk script"
    else
      echo "Need sudo permission to update $SCRIPT_PATH"
      sudo mv "$TEMP_FILE" "$SCRIPT_PATH"
      sudo chmod +x "$SCRIPT_PATH"
      echo "Successfully updated ddk script"
    fi
  else
    rm -f "$TEMP_FILE"
    echo "Error: failed to download latest ddk script" >&2
    exit 1
  fi
  exit 0
fi

if [[ -z "$TARGET" ]]; then
  # Try environment variable fallback
  if [[ -n "${DDK_TARGET:-}" ]]; then
    TARGET="$DDK_TARGET"
  else
    echo "Error: target is required. Use --target or provide it as the first positional argument, or set DDK_TARGET." >&2
    usage
    exit 2
  fi
fi

IMAGE="$IMAGE_BASE:${TARGET}"

# Build docker run base args
# Force platform to linux/amd64 to ensure consistent x86 toolchain
DOCKER_COMMON_ARGS=(--platform linux/amd64 --rm -v "$(pwd)":/build -w /build)

run_docker() {
  # run_docker [extra docker args...] -- <cmd...>
  local docker_args=("${DOCKER_COMMON_ARGS[@]}")
  while [[ $# -gt 0 ]]; do
    if [[ "$1" == "--" ]]; then shift; break; fi
    docker_args+=("$1"); shift
  done
  # remaining args are command to run
  docker run "${docker_args[@]}" "$IMAGE" "$@"
}

case "$cmd" in
  pull)
    echo "Pulling image: $IMAGE"
    docker pull "$IMAGE"
    ;;

  build)
    echo "Building in container: $IMAGE"
    # If MAKE_ARGS empty, just call make
    if [[ ${#MAKE_ARGS[@]} -eq 0 ]]; then
      run_docker -- make
    else
      run_docker -- make "${MAKE_ARGS[@]}"
    fi
    ;;

  clean)
    echo "Cleaning in container: $IMAGE"
    run_docker -- make clean
    ;;

  shell)
    echo "Starting interactive shell in: $IMAGE"
    # Prefer bash if available inside image, fall back to sh
    docker run -it "${DOCKER_COMMON_ARGS[@]}" "$IMAGE" sh -c 'if [ -x /bin/bash ]; then exec /bin/bash; else exec /bin/sh; fi'
    ;;

  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac

exit 0
